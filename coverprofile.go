package coverprofile

import (
	"go/token"
	"path/filepath"
	"reflect"
	"strings"

	"golang.org/x/tools/cover"
	"golang.org/x/tools/go/analysis"
)

var (
	flagCoverProfile string
)

func init() {
	Analyzer.Flags.StringVar(&flagCoverProfile, "coverprofile", "coverprofile", "file name of coverprofile")
}

type File struct {
	TokenFile *token.File
	Name      string
	Mode      string
	Blocks    []*Block
}

type Block struct {
	Start, End     token.Pos
	NumStmt, Count int
}

var Analyzer = &analysis.Analyzer{
	Name:       "coverprofile",
	Doc:        Doc,
	Run:        run,
	ResultType: reflect.TypeOf(([]*File)(nil)),
}

const Doc = "coverprofile parses a coverprofile file which generated by go test with -coverprofile option"

func run(pass *analysis.Pass) (result interface{}, rerr error) {
	result = ([]*File)(nil)

	if p := pass.Pkg.Path(); strings.HasSuffix(p, "_test") ||
		strings.HasSuffix(p, ".test") {
		return
	}

	var dir string
	pass.Fset.Iterate(func(f *token.File) bool {
		fname := f.Name()
		if filepath.Ext(fname) == ".go" &&
			!strings.HasSuffix(fname, "_test.go") {
			dir = filepath.Dir(fname)
			return false
		}
		return true
	})

	if dir == "" {
		return
	}

	fname := filepath.Join(dir, flagCoverProfile)
	ps, err := cover.ParseProfiles(fname)
	if err != nil {
		return
	}

	var fs []*File
	for _, p := range ps {
		file := &File{
			Name:   p.FileName,
			Mode:   p.Mode,
			Blocks: make([]*Block, len(p.Blocks)),
		}

		pass.Fset.Iterate(func(f *token.File) bool {
			if strings.HasSuffix(f.Name(), file.Name) {
				file.TokenFile = f
				return false
			}
			return false
		})

		if file.TokenFile == nil {
			continue
		}

		for j, b := range p.Blocks {
			file.Blocks[j] = &Block{
				Start:   file.TokenFile.LineStart(b.StartLine) + token.Pos(b.StartCol),
				End:     file.TokenFile.LineStart(b.EndLine) + token.Pos(b.EndCol),
				NumStmt: b.NumStmt,
				Count:   b.Count,
			}
		}

		fs = append(fs, file)
	}

	return fs, nil
}
